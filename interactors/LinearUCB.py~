
class LinearUCB(Interactor):
    def __init__(self,var, u_lambda,alpha=None,zeta=None,*args, **kwargs):
        super().__init__(*args, **kwargs)
        self.var = var
        self.u_lambda = u_lambda
        if alpha != None:
            self.alpha = alpha
        elif zeta != None:
            self.alpha = 1+np.sqrt(np.log(2/zeta)/2)

    def interact(self,test_users_items,items_means):
        num_users = len(test_users_items)
        already_computed = 0
        for uid, iids in test_users_items.items():
            u_items_means = items_means.copy()
            print(f'[{already_computed}/{num_users}]')
            # get number of latent factors 
            num_lat = len(u_items_means[0])
            b = np.zeros(num_lat)
            I = np.eye(num_lat)
            A = self.u_lambda*I
            for i in range(self.interactions):
                for j in range(self.interaction_size):
                    mean = np.dot(np.linalg.inv(A),b)
                    cov = np.linalg.inv(A)*self.var
                    max_i = np.NAN
                    max_item_mean = np.NAN
                    max_reward = np.NINF
                    for item, item_mean in zip(u_items_means.keys(),u_items_means):
                        # q = np.random.multivariate_normal(item_mean,item_cov)
                        reward = mean.T.dot(item_mean) + self.alpha*np.sqrt(item_mean.T.dot(cov).dot(item_mean))
                        if reward > max_reward:
                            max_i = item
                            max_item_mean = item_mean
                            max_reward = reward
                    del u_items_means[max_i]
                    del u_items_covs[max_i]
                    A += max_item_mean.dot(max_item_mean.T)
                    b += max_reward*q
            already_computed += 1
